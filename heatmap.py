# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N_rozaiNaNhVvJ7QW4axVidISxg1ybz4
"""

!pip install pymysql sqlalchemy

sql_file_path = '/content/project/sql/sql.sql'

with open(sql_file_path, 'r', encoding='utf-8') as f:
    sql_query = f.read()

print(sql_query[:500])

import sqlite3
import pandas as pd

# sqlite 메모리 DB 생성
conn = sqlite3.connect(':memory:')

# sql 파일 읽기
with open('/content/project/sql/sql.sql', 'r', encoding='utf-8') as f:
    sql_script = f.read()

# sql 스크립트 실행 (테이블 생성 + 데이터 삽입)
conn.executescript(sql_script)

# 쿼리 실행 후 데이터프레임으로 변환
df = pd.read_sql_query('SELECT * FROM ev', conn)

print(df.head())

from sqlalchemy import create_engine
import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# CSV 파일 경로
csv_path = '/content/project/csv/registration status.csv'  # 실제 파일 경로로 변경하세요

# CSV 불러오기, 인코딩이 UTF-8이 아닐 수도 있으니 인코딩 옵션 확인 필요
df = pd.read_csv(csv_path, encoding='utf-8')

# 데이터 확인
print(df.head())

# map_df['값'] = pd.to_numeric(map_df['값'], errors='coerce')
# map_df = map_df.dropna(subset=['값'])

# for f in geo_data['features']:
#     print(f['properties']['name'])  # 이 값과 map_df['지역명'] 이 일치해야 함

import pandas as pd

# 예시: 엑셀 또는 CSV에서 바로 읽어온 형태라고 가정
data = {
    '서울': [88212],
    '부산': [48623],
    '대구': [37027],
    '인천': [62986],
    '광주': [16641],
    '대전': [22843],
    '울산': [10786],
    '세종': [5934],
    '경기': [169781],
    '강원': [22455],
    '충북': [28860],
    '충남': [34545],
    '전북': [26902],
    '전남': [35169],
    '경북': [37957],
    '경남': [52856],
    '제주': [52529]
}

df = pd.DataFrame(data)

# 행 1개짜리 wide 형태 → long 형태로 변환
map_df = df.melt(var_name='지역명', value_name='값')
print(map_df)

지역명_매핑 = {
    '서울': '서울특별시',
    '부산': '부산광역시',
    '대구': '대구광역시',
    '인천': '인천광역시',
    '광주': '광주광역시',
    '대전': '대전광역시',
    '울산': '울산광역시',
    '세종': '세종특별자치시',
    '경기': '경기도',
    '강원': '강원도',
    '충북': '충청북도',
    '충남': '충청남도',
    '전북': '전라북도',
    '전남': '전라남도',
    '경북': '경상북도',
    '경남': '경상남도',
    '제주': '제주특별자치도'
}

map_df['지역명'] = map_df['지역명'].map(지역명_매핑)

pip install streamlit streamlit-folium

import streamlit as st
import folium
import json
import pandas as pd
from streamlit_folium import folium_static

# ---------------------------
# 샘플 데이터프레임 (map_df) 예시
# 실제로는 CSV 불러오기나 DB에서 가져와도 됩니다
map_df = pd.DataFrame({
    '지역명': ['서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종', '경기', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'],
    '값': [88212, 48623, 37027, 62986, 16641, 22843, 10786, 5934, 169781, 22455, 28860, 34545, 26902, 35169, 37957, 52856, 52529]
})

# ---------------------------
# GeoJSON 파일 불러오기
with open('/content/project/map/skorea_provinces_geo.json', encoding='utf-8') as f:
    geo_data = json.load(f)

# 값 딕셔너리 만들기
value_dict = map_df.set_index('지역명')['값'].to_dict()

# 각 지역 feature에 'value' 필드 추가
for feature in geo_data['features']:
    region_name = feature['properties']['name']
    feature['properties']['value'] = value_dict.get(region_name, '값 없음')

# ---------------------------
# 지도 생성
m = folium.Map(location=[36.5, 127.5], zoom_start=7)

# Choropleth
folium.Choropleth(
    geo_data=geo_data,
    data=map_df,
    columns=['지역명', '값'],
    key_on='feature.properties.name',
    fill_color='YlOrRd',
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name='지역별 값'
).add_to(m)

# 툴팁 표시용 투명 레이어
folium.GeoJson(
    geo_data,
    style_function=lambda feature: {
        'fillColor': 'transparent',
        'color': 'transparent',
        'weight': 0,
    },
    tooltip=folium.GeoJsonTooltip(
        fields=['name', 'value'],
        aliases=['', ''],
        localize=True,
        style="""
            font-size: 16px;
            font-weight: bold;
            background-color: white;
            border: 1px solid black;
            border-radius: 3px;
            box-shadow: 3px;
        """
    )
).add_to(m)

# ---------------------------
# Streamlit으로 출력
st.title("📍 대한민국 지역별 데이터 지도")
folium_static(m)

!pip install streamlit

!wget -q -O - ipv4.icanhazip.com
!streamlit run app.py & npx localtunnel --port 8501



print([f['properties']['name'] for f in geo_data['features']])

import pandas as pd
import folium
import json

# 데이터 숫자형으로 변환 및 NaN 처리
df['값'] = pd.to_numeric(df['값'], errors='coerce')
df = df.dropna(subset=['값'])

# Choropleth 생성
m = folium.Map(location=[36.5, 127.5], zoom_start=7)

folium.Choropleth(
    geo_data=geo_data,
    data=df,
    columns=['지역명', '값'],
    key_on='feature.properties.name',
    fill_color='YlGnBu',
    fill_opacity=0.7,
    line_opacity=0.3,
    legend_name='데이터 값'
).add_to(m)

m

print(df.dtypes)
print(df['값'].apply(type).value_counts())

df = df.dropna(subset=['값']).copy()

print(df[df['값'].isna()])

print(df['값'].head(10))
print(df['지역명'].head(10))

folium.Choropleth(
    geo_data=geo_data,
    data=df,
    columns=['지역명', '값'],
    key_on='feature.properties.name',
    fill_color='YlGnBu',
    fill_opacity=0.7,
    line_opacity=0.3,
    legend_name='데이터 값'
).add_to(m)

for i, v in enumerate(df['값']):
    if not isinstance(v, (int, float)):
        print(i, v, type(v))

print(df.head())               # 데이터프레임 일부 출력
print(df.dtypes)               # 컬럼별 타입 출력

print(df['값'].apply(type).value_counts())  # '값' 컬럼에 어떤 타입들이 있는지

# 숫자 변환 불가능한 값 출력
for i, v in enumerate(df['값']):
    if not (isinstance(v, (int, float)) and not isinstance(v, bool)):
        print(f"Non-numeric at index {i}: value={v}, type={type(v)}")



